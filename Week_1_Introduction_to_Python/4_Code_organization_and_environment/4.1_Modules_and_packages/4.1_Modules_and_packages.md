# Модули и пакеты

В Python разделение кода осуществляется с помощью модулей и пакетов. Модуль в Python
— это обычный файл с расширением `.py`, который содержит определения переменных,
функций, классов, и который также может содержать импорты других модулей. Импорт
выполняется стандартной командой `import`.

Python импортирует модуль и выполняет все инструкции, которые в этом модуле на
верхнем уровне определены.

Иногда модулей недостаточно, используются более крупные объединения — пакеты.
Пакеты в Python — это директория, которая содержит один или больше модулей. Внутри
пакетов могут содержаться другие пакеты. Внутри директории с пакетом должен находиться файл `__init__.py` (обычно пустой). Этот файл выполняется каждый раз, когда
мы импортируем пакет.

Конструкция 
```python
from mymodule import my_function
```
позволяет импортировать только определённые объявления из модуля. Чтобы импортировать все объявления из модуля, пишут 
```python
from mymodule import *
```
Установка сторонних пакетов производится с помощью утилиты `pip`, а описания библиотек можно посмотреть на сайте [pypi.org](https://pypi.org/).

## Создание нового модуля

Создадим новый модуль. Перейдем в консоль, создадим директорию `myproject`, в которой мы будем работать. 
Перейдем в нее. Внутри директории `myproject` давайте создадим модуль, назовем его `mymodule` с расширением `.py`.
```
> mkdir myproject
> cd myproject
> touch mymodule.py
```
Далее будем наполнять `mymodule.py` кодом.
### Ипорт модуля `sys`
Давайте начнем знакомиться с импортами и посмотрим на импорт модуля из стандартной библиотеки. Это делается с помощью ключевого слова `import`. 
Заимпортируем модуль стандартной библиотеки `sys`. 
Модуль `sys` содержит всевозможные переменные, структуры, функции для того, чтобы посмотреть на что-то, связанное с интерпретатором Python. 
В данном случае мы посмотрим на то, где Python ищет модули по умолчанию. 
Эта информация находится внутри переменной `sys.path`.

Внутри `mymodule.py`:
```python
import sys

print(sys.path)
```
Запустим напрямую из командной строки
```
> python mymodule.py
```
Результат
```
['C:\\Users\\Alexander\\anaconda3\\Work\\Coursera_Diving_into_Python\\Week_1_Introduction_to_Python\\4_Code_organ
ization_and_environment\\4.1_Modules_and_packages\\myproject', 'C:\\Program Files\\Python38\\python38.zip', 'C:\\
Program Files\\Python38\\DLLs', 'C:\\Program Files\\Python38\\lib', 'C:\\Program Files\\Python38', 'C:\\Users\\Al
exander\\AppData\\Roaming\\Python\\Python38\\site-packages', 'C:\\Users\\Alexander\\AppData\\Roaming\\Python\\Pyt
hon38\\site-packages\\win32', 'C:\\Users\\Alexander\\AppData\\Roaming\\Python\\Python38\\site-packages\\win32\\li
b', 'C:\\Users\\Alexander\\AppData\\Roaming\\Python\\Python38\\site-packages\\Pythonwin', 'C:\\Program Files\\Pyt
hon38\\lib\\site-packages']
```
Это список директорий, в которых Python по умолчанию ищет модули. 
Обратите внимание, что на первом месте написана директория, в которой мы сейчас находимся. 
То есть Python будет искать модули в этой директории в первую очередь, 
поэтому ничто нам не мешает запустить интерактивный интерпретатор Python и попробовать заимпортировать наш модуль.
```
> python
>>> import mymodule
['', 'C:\\Program Files\\Python38\\python38.zip', 'C:\\Program Files\\Python38\\DLLs', 'C:\\Program Files\\Python38\\lib', 'C:\\Program Files\\Python38', 'C:\\Users\\Alexander\\AppData\\Roaming\\Python\\Python38\\site-packages', 'C:\\U
sers\\Alexander\\AppData\\Roaming\\Python\\Python38\\site-packages\\win32', 'C:\\Users\\Alexander\\AppData\\Roaming\\Python\\Python38\\site-packages\\win32\\lib', 'C:\\Users\\Alexander\\AppData\\Roaming\\Python\\Python38\\site-packages
\\Pythonwin', 'C:\\Program Files\\Python38\\lib\\site-packages']
>>>
```
Если вызовем `import mymodule` еще раз, то ничего не произойдет. Это связано с тем, что Python импортирует модуль только один раз. 
Он импортирует имя модуля в локальное пространство имен, и в дальнейшем, если мы делаем точно такой же импорт, 
импорта не происходит, потому что Python видит, что мы уже ранее этот модуль импортировали, импорт закеширован. 
Когда происходит импорт, что вообще происходит? Python импортирует модуль и выполняет все инструкции, которые в этом модуле на верхнем уровне определены.
```
>>> import mymodule
>>>
```

## Создание нового пакета
Создадим пакет, назовем его `mypackage`. Это директория, и внутри директории `mypackage` давайте создадим пустой файлик `__init__.py`.
```
> mkdir mypackage
> touch mypackage/__init__.py
```
Это специальный файл, который должен содержать пакет для того, чтобы интерпретироваться Python'ом как пакет. На самом деле начиная с Python'a 3.3 есть так называемый `mainspace packages`, который не требует наличия `__init__.py` файлика в них. Но мы будем с вами рассматривать обычные `regular packages`, которые вы обычно будете видеть на практике. Этот файл `__init__.py`, который будет выполняться каждый раз, когда мы импортируем наш пакет. 

Давайте посмотрим на примере. Создадим пусковой файл `run_mypack.py`. 
```
import mypackage
print(mypackage)
```
Теперь мы будем импортировать не модуль стандартной библиотеки, а пакет, который мы только что создали. Запустим:
```
> python run_mypack.py
<module 'mypackage' from 'C:\\Users\\Alexander\\anaconda3\\Work\\Coursera_Diving_into_Python\\Week_1_Introduction_to_Python\\4_Code_organization_and_environment\\4.1_Modules_and_packages\\myproject\\mypackage\\__init__.py'>
```
Мы видим, что у нас импорт прошел успешно, мы не получили никаких ошибок, и видим, что `mypackag`e на самом деле представляет собой модуль. Пакеты — это тоже модули. Давайте теперь внутри файлика `__init__.py` в модуле `mypackage` напишем немножко кода.
```python
print("importing mypackage")
```
Целью нашей является удостовериться, что файлик `__init__.py` вызывается каждый раз, когда мы импортируем пакет `mypackage` из нашего модуля `run_mypack`.
```
> python run_mypack.py
importing mypackage
<module 'mypackage' from 'C:\\Users\\Alexander\\anaconda3\\Work\\Coursera_Diving_into_Python\\Week_1_Introduction_to_Python\\4_Code_organization_and_environment\\4.1_Modules_and_packages\\myproject\\mypackage\\__init__.py'>
```
Видим, что на экран напечаталась строка, которую мы написали. Это значит, что файлик `__init__.py` был выполнен при импорте. Давайте посмотрим на директорию, которая у нас получилась.
```
> tree /f
Структура папок
C:.
│   mymodule.py
│   run_mypack.py
├───.idea
│   │   .gitignore
│   │   misc.xml
│   │   modules.xml
│   │   myproject.iml
│   │   vcs.xml
│   │   workspace.xml
│   └───inspectionProfiles
│           profiles_settings.xml
├───mypackage
│   │   __init__.py
│   └───__pycache__
│           __init__.cpython-38.pyc
└───__pycache__
        mymodule.cpython-38.pyc
```
Однако обратите внимание, что помимо тех директорий и файлов, которые мы создавали сами, Python автоматически создал директорию, которая называется `__pycache__` , а также файлики с расширением `.pyc`. Что это такое? Директория `__pycache__` и файлик с расширением `.pyc` содержат скомпилированное представление нашего кода. Виртуальная машина Python не выполняет напрямую код, который мы пишем сами, она прежде всего его преобразовывает в оптимизированное внутреннее представление, которое называется байткодом. Соответственно, директории `__pycache__` и файлы с расширением `.pyc` содержат как раз такое соптимизированное представление нашего кода, то есть байткод. Директориb `.idea` создана PyCharm.





